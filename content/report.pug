doctype strict
- const domParser = Components.classes['@mozilla.org/xmlextras/domparser;1'].createInstance(Components.interfaces.nsIDOMParser)
- const nonMeta = new Set([])
- nonMeta.add('reportSearchMatch')
- nonMeta.add('reportChildren')
- nonMeta.add('key')
- nonMeta.add('version')
- nonMeta.add('itemType')
- nonMeta.add('title')
- nonMeta.add('creators')
- nonMeta.add('note')
- nonMeta.add('collections')
- nonMeta.add('relations')
- nonMeta.add('tags')
- nonMeta.add('deleted')
- nonMeta.add('parentItem')
- nonMeta.add('charset')
- nonMeta.add('contentType')
- nonMeta.add('linkMode')
- nonMeta.add('path')
mixin metadata(item)
  - var table = false
  //- https://github.com/pugjs/pug/issues/3020 is pretty dumb people. Make a breaking change already.
  each field in Object.keys(item)
    if nonMeta.has(field) || field == 'dateAdded' || field == 'dateModified'
      - table = false
    else if field == 'creators'
      - table = item[field].length
    else
      - item[field] = `${item[field]}`.trim()
      - table = item[field] && fieldName(item.itemType, field)

    if table
      - break

  if table
    table
      tr.itemType
        th #{Zotero.getString('itemFields.itemType')}
        td #{Zotero.ItemTypes.getLocalizedString(item.itemType)}

      //- Creators
      if item.creators
        each creator in item.creators
          tr.creator(class=creator.creatorType)
            th(class=creator.creatorType) #{Zotero.getString('creatorTypes.' + creator.creatorType)}
            td
              if typeof creator.name !== 'undefined'
                //- One field
                | #{creator.name}
              else
                //- Two field
                | #{(creator.firstName + ' ' + creator.lastName).trim()}

      //- Move dateAdded and dateModified to the end of the object
      - var da = item.dateAdded
      - var dm = item.dateModified
      - delete item.dateAdded
      - delete item.dateModified
      - item.dateAdded = da
      - item.dateModified = dm

      //- https://github.com/pugjs/pug/issues/3020 is pretty dumb people. Make a breaking change already.
      each field in Object.keys(item)
        if nonMeta.has(field) || !fieldName(item.itemType, field)
          - continue
        - value = item[field]

        tr(class=fieldAlias[`${item.itemType}.${field}`] || field)
          th #{fieldName(item.itemType, field)}
          td
            if field == 'url' && value.match(/^https?:\/\//)
              //- URL
              a(href=value) #{value}
            else if field == 'DOI'
              //- Hyperlink DOI
              a(href=`http://doi.org/${value}`) #{value}
            else if field == 'date'
              //- Remove SQL date from multipart dates
              //- (e.g. '2006-00-00 Summer 2006' becomes 'Summer 2006')
              | #{Zotero.Date.multipartToStr(value)}
            else if field == 'accessDate' || field == 'dateAdded' || field == 'dateModified'
              //- Convert dates to local format
              | #{Zotero.Date.isoToDate(value, true).toLocaleString()}
            else
              | #{value}
//-
mixin tags(item)
  if item.tags && item.tags.length
    h3.tags #{Zotero.getString('report.tags')}
    ul.tags
      each tag in item.tags
        li #{tag.tag}
//-
mixin attachments(item)
  if item.attachments && item.attachments.length
    h3.attachments #{Zotero.getString('itemFields.attachments')}
    ul.attachments
      each attachment in item.attachments
        li(id=`item_${attachment.key}`)
          if attachment.title
            | #{attachment.title}

          //- Attachment tags
          +tags(attachment)

          //- Attachment note
          if attachment.note
            div.note
              +note(attachment.note)
//-
mixin note(text)
  //- If HTML tag or entity, parse as HTML
  if text.match(/(<(p|ul|ol|div|a|br|b|i|u|strong|em( >))|&[a-z]+;|&#[0-9]+;)/)
    //- Strip control characters (for notes that were
    //- added before item.setNote() started doing this)
    | !{domParser.parseFromString(`<div>${text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '')}</div>`, 'text/html').body.innerHTML}
  else
    //- Otherwise, treat as plain text
    p.plaintext #{text}
//-
html
  head
    meta(http-equiv='Content-Type' content='text/html; charset=utf-8')
    title #{Zotero.getString('report.title.default')}
    link(rel='stylesheet' type='text/css' href='zotero://report/detail.css')
    link(rel='stylesheet' type='text/css' media='screen,projection' href='zotero://report/detail_screen.css')
    link(rel='stylesheet' type='text/css' media='print' href='zotero://report/detail_print.css')
  body
    ul.report(class={combineChildItems: 'combineChildItems'})
      each item in items
        li.item(id=`item_${item.key}` class=item.itemType)
          if item.title
            if item.reportSearchMatch
              //- Top-level item matched search, so display title
              h2 #{item.title}
            else
              //- Non-matching parent, so display "Parent Item: [Title]"
              h2.parentItem
                | #{Zotero.getString('report.parentItem')}
                span #{item.title}

          //- If parent matches search, display parent item metadata table and tags
          if item.reportSearchMatch
            +metadata(item)
            +tags(item)

            //- Independent note
            if item.note
              +note(item.note)

          //- Children
          if item.reportChildren
            //- Child notes
            if item.reportChildren.notes.length
              //- Only display "Notes:" header if parent matches search
              if item.reportSearchMatch
                h3.notes #{Zotero.getString('report.notes')}

              ul.notes
                each note in item.reportChildren.notes
                  li(id=`item_${note.key}`)
                    +note(note.note)
                    +tags(note)

            //- Child attachments
            +attachments(item.reportChildren)

          //- Related items
          if item.relations
            h3.related #{Zotero.getString('itemFields.related')}
            ul.related
              each relation in item.relations
                li(id=`item_${relation.key}`) #{relation.title}
    script
      include report.js
